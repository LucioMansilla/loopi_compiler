CREATE TABLE movimiento(
nro_movimiento INT PRIMARY KEY,
nro_cuenta INT,
fecha DATE,
debe NUMERIC(10,2),
haber NUMERIC(10,2),

constraint fk_nro_cuenta foreign key references 

);

create table cuenta(
    nro_cuenta int primary key,
    saldo numeric(10,2)
);

create sequence secuenciaNroMov increment by 1 start with 1;

insert into cuenta(nro_cuenta,saldo) values (1,0);

select * from cuenta;

create or replace procedure update_saldo(nro_cuentap in int, debep in numeric, haberp in numeric, fechita in date) as
saldoAux NUMBER :=0;
accountExists INT :=0;
begin
  select count(*) into accountExists from cuenta where (cuenta.nro_cuenta = nro_cuentap);
  if (accountExists = 0) then 
    RAISE_APPLICATION_ERROR(-20000,'flaco fijate que el  nro de cuenta no existe') ;
   end if;
  insert into movimiento(nro_movimiento,nro_cuenta,fecha,debe,haber) values (secuenciaNroMov.nextval,1,fechita,debep,haberp);
  update cuenta set saldo = saldo + haberp - debep where (cuenta.nro_cuenta = nro_cuentap);
  select saldo into saldoAux from cuenta where cuenta.nro_cuenta = nro_cuentap;
  DBMS_OUTPUT.put_line('account : '||TO_CHAR(nro_cuentap)||' es:'||TO_CHAR(saldoAux));
end; /


begin
  update_saldo(1,300,100,TO_DATE('01-01-2022','DD-MM-YYYY'));
  update_saldo(1,100,300,TO_DATE('01-02-2022','DD-MM-YYYY'));
  update_saldo(1,100,200,TO_DATE('01-03-2022','DD-MM-YYYY'));
  update_saldo(1,100,200,TO_DATE('01-04-2022','DD-MM-YYYY'));
  update_saldo(1,100,200,TO_DATE('01-05-2022','DD-MM-YYYY'));
  update_saldo(1,100,200,TO_DATE('01-06-2022','DD-MM-YYYY'));
  update_saldo(1,400,0,TO_DATE('01-07-2022','DD-MM-YYYY'));
end
delete from movimiento;
delete from cuenta;
select * from cuenta;
select * from movimiento;

create or replace procedure calculate_saldo(nro_cuentap in int, fechita in date, res out numeric)as
CURSOR cmovimientos IS select debe,haber from movimiento where (movimiento.fecha <= fechita and movimiento.nro_cuenta = nro_cuentap);
regMovimimiento cmovimientos%ROWTYPE;
begin
res := 0;
open cmovimientos;
fetch cmovimientos into regMovimiento;
while cmovimientos%found loop
   dbms_output.put_line(regMovimiento.debe);
fetch cmovimientos into regMovimiento;
end loop;
close cmovimientos;
end; /



#include "assembly-codegen.h"

#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
typedef struct {
    void* memory_address;
    const char* assembly_register;
} SymbolTableEntry;

#define MAX_ENTRIES 7
SymbolTableEntry symbol_table[MAX_ENTRIES];
int symbol_table_count = 0;

const char* available_registers[] = {"%ebx", "%ecx", "%edx", "%esi", "%edi", "%r8d", "%r9d"};
int available_register_count = 7;

const char* get_or_add_symbol(void* memory_address) {
    for (int i = 0; i < symbol_table_count; ++i) {
        if (symbol_table[i].memory_address == memory_address) {
            return symbol_table[i].assembly_register;
        }
    }

    if (symbol_table_count >= MAX_ENTRIES) {
        exit(1);
    }

    const char* new_register = available_registers[symbol_table_count];
    symbol_table[symbol_table_count].memory_address = memory_address;
    symbol_table[symbol_table_count].assembly_register = new_register;
    symbol_table_count++;

    return new_register;
}

bool exists_in_symbol_table(void* memory_address) {
    for (int i = 0; i < symbol_table_count; ++i) {
        if (symbol_table[i].memory_address == memory_address) {
            return true;
        }
    }
    return false;
}

void generate_gnu_assembly(InstructionList* list) {
    FILE* fp = fopen("output.s", "w");

    fprintf(fp, ".section .text\n");
    fprintf(fp, ".globl _start\n");
    fprintf(fp, "_start:\n");
    const char* res_reg;
    const char* dir1_reg;
    const char* dir2_reg;

    Instruction* current = list->head;
    while (current != NULL) {
        res_reg = NULL;
        dir1_reg = NULL;
        dir2_reg = NULL;

        switch (current->op_code) {
            case MOV_C:
                fprintf(fp, "    mov $%d, %d(%ebp)\n", current->dir1->value, current->res->offset);
                break;
            case MOV_V:
                fprintf(fp, "    mov %d(%ebp) , %%eax\n", current->dir1->offset);
                fprintf(fp, "    mov %%eax, %d(%ebp)\n", current->res->offset);
                break;
            case RETURN_A:
                if (exists_in_symbol_table(current->res)) {
                    res_reg = get_or_add_symbol(current->res);
                    fprintf(fp, "    mov %s, %%ebx\n", res_reg);
                } else
                    fprintf(fp, "    mov $%d, %%ebx\n", current->res->value);

                fprintf(fp, "    mov $1, %%eax\n");
                fprintf(fp, "    int $0x80\n");

                break;
            case ADD_I:
                res_reg = get_or_add_symbol(current->res);
                if (exists_in_symbol_table(current->dir1)) {
                    dir1_reg = get_or_add_symbol(current->dir1);
                    fprintf(fp, "    mov %s, %s\n", dir1_reg, res_reg);
                } else {
                    fprintf(fp, "    mov $%d, %s\n", current->dir1->value, res_reg);
                }
                if (exists_in_symbol_table(current->dir2)) {
                    dir2_reg = get_or_add_symbol(current->dir2);
                    fprintf(fp, "    add %s, %s\n", dir2_reg, res_reg);
                } else {
                    fprintf(fp, "    add $%d, %s\n", current->dir2->value, res_reg);
                }
                break;

            case MULT_I:  // mul enteros
                res_reg = get_or_add_symbol(current->res);
                if (exists_in_symbol_table(current->dir1)) {
                    dir1_reg = get_or_add_symbol(current->dir1);
                    fprintf(fp, "    mov %s, %s\n", dir1_reg, res_reg);
                } else {
                    fprintf(fp, "    mov $%d, %s\n", current->dir1->value, res_reg);
                }
                if (exists_in_symbol_table(current->dir2)) {
                    dir2_reg = get_or_add_symbol(current->dir2);
                    fprintf(fp, "    imul %s, %s\n", dir2_reg, res_reg);
                } else {
                    fprintf(fp, "    imul $%d, %s\n", current->dir2->value, res_reg);
                }

                break;
            default:
                break;
        }
        current = current->next;
    }

    fclose(fp);
}



